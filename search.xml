<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[看完视频，做一个简单的三层架构实例吧]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%9C%8B%E5%AE%8C%E8%A7%86%E9%A2%91%EF%BC%8C%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%AE%9E%E4%BE%8B%E5%90%A7%2F</url>
    <content type="text"><![CDATA[一、三层组成A.表示层（也称视图层）前台对应于MVC中的View;后台对应于MVC中的Controller，用于控制跳转、调用业务逻辑层Servlet;B.业务逻辑层(Service层)接受表示层的请求;组装数据访问层,进行的操作是逻辑性的C.数据访问层(Dao层)直接访问数据库的操作,原子性的操作(增删改查); D.三层之间的关系:上层将请求传递给下层,下层处理后,返回给上层 二、实例—在前台向数据库插入学生信息首先,在这个实例中,学生信息包括学号、姓名、年龄、地址这四个方面用户在前台输入这些信息点击提交后，向业务逻辑层发出请求，业务逻辑层通过调用数据访问层的方法，先调用查询操作，判断此学生是否在数据库已经存在；若不存在则接着调用插入操作，并把操作结果返回值表示层。 运行结果先看一下数据库中已存在的学生信息添加一个已经存在的学生添加一个不存在的学生添加成功后的数据库表信息 代码实现项目结构 index.jsp123456789101112131415&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;添加学生&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="AddStudentServlet" method="post"&gt; 学号：&lt;input type="number" name="stuNo"&gt;&lt;br&gt; 姓名：&lt;input type="text" name="stuName"&gt;&lt;br&gt; 年龄：&lt;input type="number" name="stuAge"&gt;&lt;br&gt; 地址：&lt;input type="text" name="stuAddress"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; AddStudentServlet.java123456789101112131415161718192021222324252627282930313233343536373839package com.ajy.servlet;import com.ajy.entity.Student;import com.ajy.service.AddStudentService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "AddStudentServlet",value = "/AddStudentServlet")public class AddStudentServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); int stuNo = Integer.parseInt(request.getParameter("stuNo")); String stuName = request.getParameter("stuName"); int stuAge = Integer.parseInt(request.getParameter("stuAge")); String stuAddress = request.getParameter("stuAddress"); Student stu = new Student(stuNo,stuName,stuAge,stuAddress); AddStudentService addStudentService = new AddStudentService(); boolean res = addStudentService.addStudent(stu); response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); if (res)&#123; out.print("添加成功"); &#125;else&#123; out.print("添加失败"); &#125; &#125;&#125; AddStudentService.java12345678910111213141516package com.ajy.service;import com.ajy.dao.StudentDao;import com.ajy.entity.Student;public class AddStudentService &#123; StudentDao studentDao = new StudentDao(); public boolean addStudent(Student stu)&#123; if (!studentDao.isExits(stu))&#123; return studentDao.addStudent(stu); &#125;else&#123; return false; &#125; &#125;&#125; StudentDao.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.ajy.dao;import com.ajy.entity.Student;import java.sql.*;public class StudentDao &#123; private final String URL="jdbc:mysql://localhost:3306/anjiyubase?&amp;serverTimezone=UTC&amp;useSSL=false"; private final String DRIVER="com.mysql.cj.jdbc.Driver"; private final String NAME="root"; private final String PWD="121181"; public boolean isExits(Student stu)&#123; return queryStudent(stu.getStuNo())==null?false:true; &#125; public boolean addStudent(Student stu)&#123; Connection con = null; PreparedStatement pstmt = null; int count = 0; try &#123; Class.forName(DRIVER); con = DriverManager.getConnection(URL,NAME,PWD); String sql = "insert into student values(?,?,?,?)"; pstmt = con.prepareStatement(sql); pstmt.setInt(1,stu.getStuNo()); pstmt.setString(2,stu.getStuName()); pstmt.setInt(3,stu.getStuAge()); pstmt.setString(4,stu.getStuAddress()); count = pstmt.executeUpdate(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; catch (SQLException e) &#123; e.printStackTrace(); return false; &#125;finally &#123; try &#123; if (pstmt!=null)pstmt.close(); if (con!=null)con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); return false; &#125; &#125; if(count==0)&#123; return false; &#125;else&#123; return true; &#125; &#125; public Student queryStudent(int stuNo)&#123; Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; Student stu = null; int count = 0; try &#123; Class.forName(DRIVER); con = DriverManager.getConnection(URL,NAME,PWD); String sql = "select * from student where sno=?"; pstmt = con.prepareStatement(sql); pstmt.setInt(1,stuNo); rs = pstmt.executeQuery(); if (rs.next())&#123; stu = new Student(rs.getInt("sno"), rs.getString("sname"), rs.getInt("sage"), rs.getString("saddress")); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return null; &#125; catch (SQLException e) &#123; e.printStackTrace(); return null; &#125;finally &#123; try &#123; if (rs!=null)rs.close(); if (pstmt!=null)pstmt.close(); if (con!=null)con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); return null; &#125; &#125; return stu; &#125;&#125; Student.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ajy.entity;public class Student &#123; private int stuNo; private String stuName; private int stuAge; private String stuAddress; public Student(int stuNo,String stuName,int stuAge,String stuAddress)&#123; this.stuNo = stuNo; this.stuName = stuName; this.stuAge = stuAge; this.stuAddress = stuAddress; &#125; public int getStuNo() &#123; return stuNo; &#125; public void setStuNo(int stuNo) &#123; this.stuNo = stuNo; &#125; public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; public int getStuAge() &#123; return stuAge; &#125; public void setStuAge(int stuAge) &#123; this.stuAge = stuAge; &#125; public String getStuAddress() &#123; return stuAddress; &#125; public void setStuAddress(String stuAddress) &#123; this.stuAddress = stuAddress; &#125;&#125;]]></content>
      <categories>
        <category>服务器端开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Servlet的MVC模式用户登录实例]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%9F%BA%E4%BA%8EServlet%E7%9A%84MVC%E6%A8%A1%E5%BC%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[一、关于MVC模式的简单解释M Model，模型层，例如登录实例中，用于处理登录操作的类；V View，视图层，用于展示以及与用户交互。使用html、js、css、jsp、jQuery等前端技术实现；C Controller，控制器，接受视图层的请求，将请求跳转到对应的模型进行处理，模型层处理完毕后，再将结果返回给请求处。这里用Servlet实现控制器。 二、实现过程分析用户再视图层输入用户名以及密码点击提交，向控制器发出请求控制器（Servlet）接受请求，将接受到的用户名以及密码转给模型层模型层依据用户名和密码在数据库中进行查询，将操作结果返回给控制器控制器经过判断返回给用户登录结果。 三、代码实现项目结构图 视图层实现(index.jsp)12345678910111213&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="LoginServlet" method="post"&gt; Name:&lt;input type="text" name="uname"&gt;&lt;br&gt; Pass:&lt;input type="password" name="upwd"&gt;&lt;br&gt; &lt;input type="submit" value="Login"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 控制器层实现(LoginServlet)1234567891011121314151617181920212223242526272829303132333435363738package com.ajy.Servlet;import com.ajy.Model.LoginDao;import com.ajy.Entity.User;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;//控制器层public class LoginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //处理post方式登录请求 request.setCharacterEncoding("utf-8"); String uname = request.getParameter("uname"); String upwd = request.getParameter("upwd"); User user = new User(uname,upwd); response.setContentType("text/html;charset=utf-8"); response.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); int rs = LoginDao.Login(user); if(rs==-1)&#123; out.println("系统错误"); &#125;else if(rs==0)&#123; out.println("用户名或密码错误"); &#125;else&#123; out.println("登录成功"); &#125; &#125;&#125; 模型层实现(LoginDao)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ajy.Model;import com.ajy.Entity.User;import java.sql.*;//模型层，用于处理登录操作public class LoginDao &#123; private static String DBUname = "root"; private static String DBUpwd = "121181"; private static String URL="jdbc:mysql://localhost:3306/anjiyubase?&amp;serverTimezone=UTC&amp;useSSL=false"; public static int Login(User user)&#123; Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; int count = 0; try &#123; Class.forName("com.mysql.cj.jdbc.Driver"); con = DriverManager.getConnection(URL,DBUname,DBUpwd); pstmt = con.prepareStatement("select count(*) from users where uanme = ? and upwd = ?"); pstmt.setString(1,user.getUserName()); pstmt.setString(2,user.getUserPassword()); rs = pstmt.executeQuery(); if(rs.next())&#123; count = rs.getInt(1); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return -1; &#125; catch (SQLException e) &#123; e.printStackTrace(); return -1; &#125;finally &#123; try &#123; if (rs!=null)rs.close(); if (pstmt!=null)pstmt.close(); if (con!=null)con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); return -1; &#125; &#125; if (count==0)&#123; return 0; &#125;else&#123; return 1; &#125; &#125;&#125; 用户实例(User)123456789101112131415161718192021222324252627282930313233package com.ajy.Entity;public class User &#123; private int id; private String UserName; private String UserPassword; public User(String UserName, String UserPassword)&#123; this.UserName=UserName; this.UserPassword=UserPassword; &#125; public User(int id, String UserName, String UserPassword)&#123; this.id=id; this.UserName=UserName; this.UserPassword=UserPassword; &#125; public String getUserName() &#123; return UserName; &#125; public void setUserName(String userName) &#123; UserName = userName; &#125; public String getUserPassword() &#123; return UserPassword; &#125; public void setUserPassword(String userPassword) &#123; UserPassword = userPassword; &#125;&#125; web.xml中的内容123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ajy.Servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 数据库]]></content>
      <categories>
        <category>服务器端开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用BottomNavigationView横屏时返回主页]]></title>
    <url>%2F2019%2F04%2F25%2F%E4%BD%BF%E7%94%A8BottomNavigationView%E6%A8%AA%E5%B1%8F%E6%97%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[一、问题导入如图，“发现”页即为主页，然后我们切换到“我”页，一切正常。 那么问题来了，如果切换到“我”页后把手机横屏，则会出现下面的情况。 嗯？怎么又回到“发现”页了？？ 二、解决办法思考据自己了解，Android应用程序刷新页面有两种情况，第一种是用户操作；第二种非用户操作，即系统触发的。很明显这是系统触发的咯。然后，搬来Android应用程序生命周期图： 看到，在整个生命周期中，APP会调用onCreate()、onStart()、onResume()、onPause()、onStop()、onRestart()、onDestroy()这几个函数。所以，我在MainActivity.java中重构这几个函数，使用LogCat来验证在横屏的过程中，APP就调用了哪些函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MainActivity extends AppCompatActivity &#123; private BottomNavigationView bottomNavigationView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //隐藏默认的顶部导航 getSupportActionBar().hide(); //获取底部导航视图实例 bottomNavigationView = findViewById(R.id.bottomNavi); //把“发现”页作为主页 getSupportFragmentManager().beginTransaction().replace(R.id.contentFrame,new DiscoverFragment()).commit(); //注册底部导航按钮点击事件 bottomNavigationView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) &#123; FragmentTransaction transition = getSupportFragmentManager().beginTransaction(); switch (menuItem.getItemId())&#123; case R.id.bottomNavi_discover: transition.replace(R.id.contentFrame,new DiscoverFragment()).commit(); break; case R.id.bottomNavi_friends: transition.replace(R.id.contentFrame,new FriendFragment()).commit(); break; case R.id.bottomNavi_communicate: transition.replace(R.id.contentFrame,new CommunicateFragment()).commit(); break; case R.id.bottomNavi_myself: transition.replace(R.id.contentFrame,new MeFragment()).commit(); break; &#125; return true; &#125; &#125;); Log.i("MainActivity","onCreate()"); &#125; @Override protected void onStart() &#123; super.onStart(); Log.i("MainActivity","onStart()"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.i("MainActivity","onResume()"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.i("MainActivity","onPause()"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.i("MainActivity","onStop()"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.i("MainActivity","onDestroy()"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.i("MainActivity","onRestart()"); &#125;&#125; 下面运行程序，横屏后，LogCat输出如下： 仔细观察发现，横屏后，程序再次调用了onCreate()函数，页面不刷新才怪勒！ 解决思路在横屏前，先保存当前浏览的数据，然后在横屏后，恢复这个数据就可以了。所以，添加一个信号量(全局变量)，用来保存当前浏览的页面位置（1，2，3，4） 1private int PageFlag = 1; 然后再加入如下代码，目的是在程序调用onDestroy()之前，通过onSaveInstanceState()函数保存当前的PageFlag值，在横屏后调用onRestoreInstanceState()时，恢复PageFlag的值，通过此方法恢复横屏前访问的页面。 1234567891011121314151617181920212223242526272829303132@Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putInt("KEY_PAGE_INDEX",PageFlag); &#125;@Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); if (savedInstanceState!=null)&#123; PageFlag = savedInstanceState.getInt("KEY_PAGE_INDEX"); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); switch (PageFlag)&#123; case 1: transaction.replace(R.id.contentFrame,new DiscoverFragment()).commit(); PageFlag = 1; break; case 2: transaction.replace(R.id.contentFrame,new FriendFragment()).commit(); PageFlag = 2; break; case 3: transaction.replace(R.id.contentFrame,new CommunicateFragment()).commit(); PageFlag = 3; break; case 4: transaction.replace(R.id.contentFrame,new MeFragment()).commit(); PageFlag = 4; break; &#125; &#125; &#125; 再次横屏， OK，问题解决！ 注意此APP使用的是 《小黑盒APP》 中的资源，仅用于学习]]></content>
      <categories>
        <category>小App开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
